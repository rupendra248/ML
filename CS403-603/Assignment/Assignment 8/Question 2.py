# -*- coding: utf-8 -*-
"""8_ML_2_Fuzzy_CMeans.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18FWI3-6I2xxJs6_YEdHNx780aa3eCtJZ
"""

import pandas as pd
import numpy as np
import random
import operator
import math
import matplotlib.pyplot as plt

url=""
full_dataframe = pd.read_csv("/content/drive/MyDrive/CSV/wine.csv")
print(full_dataframe.head())

col = list(full_dataframe.columns)
data_featur = col[:len(col) - 1]
all_labels = list(full_dataframe[col[-1]])
dataframe = full_dataframe[data_featur]
print("All columns are", col)
print("Total Features are", data_featur)
print("The Class Labels are", all_labels)
print("\n\n\nThe dataframe is\n", dataframe)

# Number of Clusters
k = 3
# Maximum number of iterations
Maximum_Iteration = 100
# Number of data points
n = len(dataframe)
# Fuzzy parameter
m = 1.7 #Select a value greater than 1 else it will be knn

plt.figure(figsize=(6,10))
plt.scatter(list(dataframe.iloc[:, 5]), list(dataframe.iloc[:, 8]), marker='x')
plt.axis('equal')
plt.xlabel('Total phenols', fontsize=16)
plt.ylabel('Proanthocyanins', fontsize=16)
plt.title('Total phenols vs Proanthocyanins', fontsize=22)
plt.grid()
plt.show()

plt.figure(figsize=(6,10))
plt.scatter(list(dataframe.iloc[:, 6]), list(dataframe.iloc[:, 11]), marker='x')
plt.axis('equal')
plt.xlabel('Flavanoids', fontsize=16)
plt.ylabel('OD280/OD315 of diluted wines', fontsize=16)
plt.title('Flavanoids vs OD280/OD315 of diluted wines', fontsize=22)
plt.grid()
plt.show()


# Calculating the accuracy
def accuracy(cluster_labels, class_labels):
    right_prediction = 0
    class_0 = max(set(labels[0:59]), key=labels[0:59].count)
    class_1 = max(set(labels[59:130]), key=labels[59:130].count)
    class_2 = max(set(labels[130:]), key=labels[130:].count)

    for i in range(len(dataframe)):
        if cluster_labels[i] == class_0 and class_labels[i] == 0:
            right_prediction = right_prediction + 1
        if cluster_labels[i] == class_1 and class_labels[i] == 1 and class_1 != class_0:
            right_prediction = right_prediction + 1
        if cluster_labels[i] == class_2 and class_labels[i] == 2 and class_2 != class_1 and class_2 != class_1:
            right_prediction = right_prediction + 1

    acc = (right_prediction / len(dataframe)) * 100
    return acc


def initMembeMat():  # initializing the membership matrix
    member_matrix = []
    for j in range(n):
        rand_number_list1 = [random.random() for i in range(k)]
        sum_mation = sum(rand_number_list1)
        temperory_list = [x / sum_mation for x in rand_number_list1]

        fleg = temperory_list.index(max(temperory_list))
        for j in range(0, len(temperory_list)):
            if (j == fleg):
                temperory_list[j] = 1
            else:
                temperory_list[j] = 0

        member_matrix.append(temperory_list)
    return member_matrix

def cal_center_of_cluster(member_mattrix): # calculating the cluster center
    clstr_membership_value = list(zip(*member_mattrix))
    cluster_centers = []
    for j in range(k):
        x = list(clstr_membership_value[j])
        xraised = [p ** m for p in x]
        denominator = sum(xraised)
        temp_num = []
        for i in range(n):
            data_point = list(dataframe.iloc[i])
            prod = [xraised[i] * val for val in data_point]
            temp_num.append(prod)
        numerator = map(sum, list(zip(*temp_num)))
        center = [z/denominator for z in numerator]
        cluster_centers.append(center)
    return cluster_centers

member_matrix = initMembeMat()
cal_center_of_cluster(member_matrix)

def updateMembershipValue(membership_mat, cluster_centers): # Updating the membership value
    p = float(2/(m-1))
    for i in range(n):
        x = list(dataframe.iloc[i])
        distances = [np.linalg.norm(np.array(list(map(operator.sub, x, cluster_centers[j])))) for j in range(k)]
        for j in range(k):
            den = sum([math.pow(float(distances[j]/distances[c]), p) for c in range(k)])
            membership_mat[i][j] = float(1/den)
    return membership_mat

def getClusters(membership_mat): # getting the clusters
    cluster_labels = list()
    for i in range(n):
        max_val, idx = max((val, idx) for (idx, val) in enumerate(membership_mat[i]))
        cluster_labels.append(idx)
    return cluster_labels

def fuzzyCMeansClustering(): #First Iteration with centers at 0
    # Membership Matrix
    membership_mat = initMembeMat()
    curr = 0
    acc=[]
    cent_temp = [[0, 0, 0, 0],[0, 0, 0, 0],[0, 0, 0, 0]]
    while curr < Maximum_Iteration:
        if(curr == 0):
            cluster_centers = cent_temp
            print("Cluster Centers:")
            print(np.array(cluster_centers))
        else:
            cluster_centers = cal_center_of_cluster(membership_mat)
        #cluster_centers = calculateClusterCenter(member_mattrix)
        membership_mat = updateMembershipValue(membership_mat, cluster_centers)
        cluster_labels = getClusters(membership_mat)
        acc.append(cluster_labels)
        curr += 1
    print("---------------------------")
    print("Membership Matrix:")
    print(np.array(membership_mat))
    return cluster_labels, cluster_centers, acc


def fuzzyCMeansClustering():  # Second Iteration Multivariate Gaussian
    # Membership Matrix
    membership_mat = initMembeMat()
    curr = 0
    acc = []
    mean = [0, 0]
    cov = [[1, 0], [0, 1]]

    lis1, cent_temp = [], []

    for i in range(0, k):
        Z = list(np.random.multivariate_normal(mean, cov))
        Z1 = list(np.random.multivariate_normal(mean, cov))
        lis1 = Z + Z1
        cent_temp.append(lis1)

    while curr < Maximum_Iteration:
        if (curr == 0):
            cluster_centers = cent_temp
            print("Cluster Centers:")
            print(np.array(cluster_centers))
        else:
            cluster_centers = cal_center_of_cluster(membership_mat)
        # cluster_centers = calculateClusterCenter(member_mattrix)
        membership_mat = updateMembershipValue(membership_mat, cluster_centers)
        cluster_labels = getClusters(membership_mat)
        acc.append(cluster_labels)
        curr += 1
    print("---------------------------")
    print("Membership Matrix:")
    print(np.array(membership_mat))
    return cluster_labels, cluster_centers, acc


def fuzzyCMeansClustering():  # Third iteration Random vectors from data
    # Membership Matrix
    membership_mat = initMembeMat()
    curr = 0
    acc = []
    while curr < Maximum_Iteration:
        cluster_centers = cal_center_of_cluster(membership_mat)
        membership_mat = updateMembershipValue(membership_mat, cluster_centers)
        cluster_labels = getClusters(membership_mat)

        acc.append(cluster_labels)

        if (curr == 0):
            print("Cluster Centers:")
            print(np.array(cluster_centers))
        curr += 1
    print("---------------------------")
    print("Partition matrix:")
    print(np.array(membership_mat))
    # return cluster_labels, cluster_centers
    return cluster_labels, cluster_centers, acc


labels, centers, acc = fuzzyCMeansClustering()
a = accuracy(labels, all_labels)

acc_lis = []
for i in range(0,len(acc)):
    val = accuracy(acc[i], all_labels)
    acc_lis.append(val)

acc_lis = np.array(acc_lis) #calculating accuracy and std deviation 100 times
print("mean=",np.mean(acc_lis))
print("Std dev=",np.std(acc_lis))

print("Accuracy = " + str(round(a, 2)))

print("Cluster center vectors:") #final cluster centers
print(np.array(centers))